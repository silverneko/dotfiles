" :PlugInstall
call plug#begin('~/.vim/plugged')

"Plug 'sainnhe/gruvbox-material'
Plug 'sainnhe/everforest'

Plug 'itchyny/lightline.vim'

Plug 'bfrg/vim-c-cpp-modern'

Plug 'mhinz/vim-startify'

Plug 'lifepillar/vim-mucomplete'

Plug 'kshenoy/vim-signature'

Plug 'mhinz/vim-signify'

Plug 'andymass/vim-matchup'

Plug 'justinmk/vim-sneak'

Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }

Plug 'fidian/hexmode'

Plug 'tpope/vim-endwise'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-sleuth'
Plug 'tpope/vim-repeat'

Plug 'google/vim-maktaba'
Plug 'google/vim-glaive'
Plug 'google/vim-codefmt'

call plug#end()

call glaive#Install()

let g:google_vimrc=expand('~/.dotfiles/vimrc.google')
if filereadable(g:google_vimrc)
  exec 'source' g:google_vimrc
endif

Glaive codefmt google_java_executable="google-java-format --aosp"

syntax enable
filetype plugin indent on

set nocompatible

" :help persistent-undo
let undo_dir='/tmp/vim_undo'
if !isdirectory(undo_dir)
  call mkdir(undo_dir, 'p')
endif
let &undodir=undo_dir
set undofile

" mucomplate
let g:mucomplete#enable_auto_at_startup = 1
set completeopt=menuone,noselect
set shortmess+=c
call mucomplete#msg#set_notifications(1)
let g:mucomplete#chains = {
      \ 'default' : ['path', 'omni', 'keyn', 'keyp', 'dict', 'uspl'],
      \ 'vim'     : ['path', 'cmd', 'keyn']
      \ }

inoremap <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return pumvisible() ? "\<C-y>" : "\<CR>"
endfunction

" gruvbox
set t_Co=256
set termguicolors
set background=dark
" let g:gruvbox_material_background = 'hard'
" let g:gruvbox_material_better_performance = 1
" let g:gruvbox_material_visual = 'blue background'
" colorscheme gruvbox-material
let g:everforest_background = 'hard'
let g:everforest_colors_override = {}
let g:everforest_better_performance = 1

function! s:everforest_custom() abort
  let l:palette = everforest#get_palette(g:everforest_background, g:everforest_colors_override)
  call everforest#highlight('Todo', l:palette.fg, l:palette.none, 'bold,italic')
endfunction

augroup EverforestCustom
  autocmd!
  autocmd ColorScheme everforest call s:everforest_custom()
augroup END

colorscheme everforest

" lightline
set noshowmode
set display+=lastline
set cmdheight=1
set laststatus=2
set wildmenu

let g:lightline = {
      \ 'colorscheme': 'everforest',
      \ 'active': {
      \   'left': [
      \     ['mode', 'paste'],
      \     ['relativepath', 'readonly'],
      \     ['modified'],
      \   ],
      \   'right': [
      \     ['percentwin'],
      \     ['line', 'column'],
      \     ['gitbranch', 'filetype', 'my_fileencoding', 'charhexvalue'] ,
      \   ],
      \ },
      \ 'tabline': {'left': [['tabs']], 'right': []},
      \ 'tab': {'active': ['tabtitle'], 'inactive': ['tabtitle']},
      \ 'component': {
      \   'charhexvalue': '0x%02B',
      \   'modified': '%m',
      \   'line': '%3l/%LL',
      \   'column': '%2vC',
      \ },
      \ 'component_function': {
      \   'gitbranch': 'gitbranch#name',
      \   'my_fileencoding': 'MyFileencoding',
      \ },
      \ 'component_expand': {'tabs': 'MyLightlineTabs'},
      \ 'tab_component_function': {'tabtitle': 'MyTabTitle'},
      \ 'tabline_subseparator': {'left': '', 'right': ''},
      \ }

function! MyFileencoding()
  let l:enc = &fenc !=# "" ? &fenc : &enc
  return l:enc ==? "utf-8" ? "" : l:enc
endfunction

function! MyTabTitle(n)
  return '[' . a:n . '] ' . lightline#tab#filename(a:n) . (lightline#tab#modified(a:n) == '+' ? '*' : '')
endfunction

function! MyLightlineTabs() abort
  let [x, y, z] = [[], [], []]
  let nr = tabpagenr()
  let cnt = tabpagenr('$')
  for i in range(1, cnt)
    call add(i < nr ? x : i == nr ? y : z, (i > nr + 3 ? '%<' : '') . '%' . i . 'T%{lightline#onetab(' . i . ',' . (i == nr) . ')}' . (i == cnt ? '%T' : ''))
  endfor
  return [x, y, z]
endfunction

set ttimeout
augroup NoInsertKeycodes
  autocmd!
  autocmd InsertEnter * set ttimeoutlen=0
  autocmd InsertLeave * set ttimeoutlen=100 "<--- default value; also try 100 or something
augroup END

" j: Delete comment character when joining commented lines.
" o: Insert comment leader when 'o' / 'O' in Normal mode.
augroup SetFormatOptions
  autocmd!
  autocmd BufNewFile,BufRead * setlocal formatoptions-=o formatoptions+=j
augroup END

" Show search count like "[1/5]"
set shortmess-=S

set nomodeline
set noerrorbells
set splitbelow
set scrolloff=5
set sidescroll=1
set sidescrolloff=5
set history=1000
set sessionoptions-=options
set viewoptions-=options
" Persist g:UPPERCASE variables, used by some plugins, in .viminfo.
set viminfo^=!
" vim -p <FILES...> / vim <FILES...> && :tab all
set tabpagemax=50
" Disable a legacy behavior that can break plugin maps. (???)
set nolangremap

set cursorline
set ruler
set number
set numberwidth=5
set mouse=nv
set guifont=DejaVu\ Sans\ Mono\ 14
set guicursor+=a:blinkon0

set listchars=trail:␣,tab:»\ ,nbsp:¬
set list

set colorcolumn=80
set backspace=indent,eol,start
set history=500      " keep 500 lines of command line history
set showcmd          " display incomplete commands
set incsearch        " do incremental searching
set hlsearch
set ignorecase smartcase

" Tab things
set tabstop=8        "A tab is 8 spaces
set expandtab        "Always uses spaces instead of tabs
set softtabstop=2    "Insert 2 spaces when tab is pressed
set shiftwidth=2     "An indent is 2 spaces
set shiftround       "Round indent to nearest shiftwidth multiple

set autoindent
" Optional
" C/C++ programming helpers
" augroup csrc
"   autocmd!
"   autocmd FileType *      set nocindent smartindent
"   autocmd FileType c,cpp,cuda  set cindent
" augroup END
" Set a few indentation parameters. See the VIM help for cinoptions-values for
" details.  These aren't absolute rules; they're just an approximation of
" common style in LLVM source.
set cinoptions=:0,g0,(0,Ws,l1
" Vim tend to a have issues with flagging braces as errors, see for example
" https://github.com/vim-jp/vim-cpp/issues/16. A workaround is to set:
let c_no_curly_error = 1

augroup CustomFileTypeCommands
  autocmd!
  autocmd BufNewFile,BufRead *.aidl,*.hidl setfiletype java
  autocmd BufNewFile,BufRead *.bp set filetype=javascript softtabstop=4 shiftwidth=4
  autocmd BufNewFile,BufRead ghostty.config setfiletype ghostty
  autocmd FileType go set noexpandtab tabstop=2 colorcolumn=100
  autocmd FileType make set noexpandtab preserveindent
augroup END

" :help restore-cursor
augroup RestoreCursor
  autocmd!
  autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") | exe "normal g'\"" | endif
augroup END

" Hide cursorline on FocusLost; Show cursorline on FocusGained
augroup SetFocusedCursorline
  autocmd!
  autocmd User Startified setlocal cursorline
  autocmd BufNewFile,BufRead,FocusGained * set cursorline
  autocmd FocusLost * set nocursorline
augroup END

" :help signify.txt
let g:signify_number_highlight = 1
" Always show gutter so it doesn't flicker when making new changes
set signcolumn=yes
" Eagerly update git status
set updatetime=300

function! s:show_current_hunk() abort
  let h = sy#util#get_hunk_stats()
  if !empty(h)
    " Prevents status line flickering :h :echo-redraw
    redraw | echo printf('[Hunk %d/%d]', h.current_hunk, h.total_hunks)
  endif
endfunction

augroup ShowHunkIndexAfterJump
  autocmd!
  autocmd User SignifyHunk call s:show_current_hunk()
augroup END

nnoremap <silent> ]c <plug>(signify-next-hunk):SignifyHunkDiff<CR>
nnoremap <silent> [c <plug>(signify-prev-hunk):SignifyHunkDiff<CR>

" :help tmux-integration
if !has('gui_running') && &term =~ '^\(screen\|tmux\|xterm\)'
  " Insert / replace / normal = vertical bar / underline / block, :help termcap-cursor-shape
  let &t_SI = "\e[6 q"
  let &t_SR = "\e[4 q"
  let &t_EI = "\e[2 q"

  " Better mouse support, see  :help 'ttymouse'
  set ttymouse=sgr

  " Enable true colors, see  :help xterm-true-color
  set termguicolors
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
  let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"

  " Enable bracketed paste mode, see  :help xterm-bracketed-paste
  let &t_BE = "\<Esc>[?2004h"
  let &t_BD = "\<Esc>[?2004l"
  let &t_PS = "\<Esc>[200~"
  let &t_PE = "\<Esc>[201~"

  " Enable focus event tracking, see  :help xterm-focus-event
  let &t_fe = "\<Esc>[?1004h"
  let &t_fd = "\<Esc>[?1004l"
  execute "set <FocusGained>=\<Esc>[I"
  execute "set <FocusLost>=\<Esc>[O"

  " Enable modified arrow keys, see  :help arrow_modifiers
  execute "silent! set <xUp>=\<Esc>[@;*A"
  execute "silent! set <xDown>=\<Esc>[@;*B"
  execute "silent! set <xRight>=\<Esc>[@;*C"
  execute "silent! set <xLeft>=\<Esc>[@;*D"
endif

" Use CTRL-L to clear the highlighting of 'hlsearch' (off by default) and call
" :diffupdate.
nnoremap <silent> <C-L> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR><C-L>

" vim-signature
" m[0-9] -> Place markers
" ???, ]=, ]- -> Navigate markers

" Single character *sneak*. `;` => next sneak, `,` => previous sneak.
map f <Plug>Sneak_f
map F <Plug>Sneak_F
map t <Plug>Sneak_t
map T <Plug>Sneak_T

" Shortcuts
nnoremap <F8> :%y +<CR>

" Tab navigations
nnoremap <silent> ]t :tabnext<CR>
nnoremap <silent> [t :tabprevious<CR>
nnoremap <silent> ]T :tablast<CR>
nnoremap <silent> [T :tabfirst<CR>
nnoremap <silent> <C-A-Right> :<C-U>execute 'tabmove +' . v:count1<CR>
nnoremap <silent> <C-A-Left> :<C-U>execute 'tabmove -' . v:count1<CR>

" http://vim.wikia.com/wiki/Recover_from_accidental_Ctrl-U
inoremap <C-U> <C-G>u<C-U>
inoremap <C-W> <C-G>u<C-W>

" CTRL-C in visual mode to fast copy to system clipboard.
vnoremap <C-C> "+y

" Change directory to current file directory.
command CD cd %:p:h
command LCD lcd %:p:h
