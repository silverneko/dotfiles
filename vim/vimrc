" NOTE: {visual}K to lookup selected text in :help, see :h v_K

" vim-matchup replaces matchit.vim
let g:loaded_matchit = 1
let g:matchup_matchparen_offscreen = #{method: 'popup', fullwidth: 1}

" let g:ale_completion_enabled = 1
" let g:ale_hover_cursor = 1
" let g:ale_set_balloons = 1
" let g:ale_floating_preview = 1

" :PlugInstall
call plug#begin('~/.vim/plugged')

Plug 'sainnhe/everforest'
Plug 'itchyny/lightline.vim'

Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'
Plug 'mhinz/vim-startify'
Plug 'mhinz/vim-signify'
Plug 'kshenoy/vim-signature'
Plug 'andymass/vim-matchup'
Plug 'justinmk/vim-sneak'
Plug 'bfrg/vim-c-cpp-modern'
"Plug 'fidian/hexmode'

Plug 'tpope/vim-endwise'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-sleuth'
Plug 'tpope/vim-surround'

Plug 'girishji/vimsuggest'
Plug 'silverneko/vimcomplete'
Plug 'yegappan/lsp'
"Plug 'dense-analysis/ale'

Plug 'google/vim-maktaba'
Plug 'google/vim-glaive'
Plug 'google/vim-codefmt'

call plug#end()

call glaive#Install()

let g:google_vimrc=expand('~/.dotfiles/vimrc.google')
if filereadable(g:google_vimrc)
  exec 'source' g:google_vimrc
endif

syntax enable
filetype plugin indent on

set nocompatible

" :help persistent-undo
let undo_dir='/tmp/vim_undo'
if !isdirectory(undo_dir)
  call mkdir(undo_dir, 'p')
endif
let &undodir=undo_dir
set undofile

set ttimeout
augroup NoInsertKeycodes
  autocmd!
  autocmd InsertEnter * set ttimeoutlen=0
  autocmd InsertLeave * set ttimeoutlen=100 "<--- default value; also try 100 or something
augroup END

" j: Delete comment character when joining commented lines.
" o: Insert comment leader when 'o' / 'O' in Normal mode.
augroup SetFormatOptions
  autocmd!
  autocmd BufNewFile,BufRead * setlocal formatoptions-=o formatoptions+=j
augroup END

" Show search count like "[1/5]"
set shortmess-=S

set nomodeline
set noerrorbells
set splitbelow
set scrolloff=5
set sidescroll=1
set sidescrolloff=5
set history=1000
set sessionoptions-=options
set viewoptions-=options
" Persist g:UPPERCASE variables, used by some plugins, in .viminfo.
set viminfo^=!
" vim -p <FILES...> / vim <FILES...> && :tab all
set tabpagemax=50
" Disable a legacy behavior that can break plugin maps. (???)
set nolangremap

set cursorline
set ruler
set number
set numberwidth=5
set mouse=nv
set guifont=DejaVu\ Sans\ Mono\ 14
set guicursor+=a:blinkon0

set listchars=trail:␣,tab:»\ ,nbsp:¬
set list

set backspace=indent,eol,start
set history=500      " keep 500 lines of command line history
set showcmd          " display incomplete commands
set incsearch        " do incremental searching
set hlsearch
set ignorecase smartcase

" Tab things
set tabstop=8        "A tab is 8 spaces
set expandtab        "Always uses spaces instead of tabs
set softtabstop=2    "Insert 2 spaces when tab is pressed
set shiftwidth=2     "An indent is 2 spaces
set shiftround       "Round indent to nearest shiftwidth multiple

set autoindent
" Set a few indentation parameters. See the VIM help for cinoptions-values for
" details.  These aren't absolute rules; they're just an approximation of
" common style in LLVM source.
set cinoptions=:0,g0,(0,Ws,l1
" Vim tend to a have issues with flagging braces as errors, see for example
" https://github.com/vim-jp/vim-cpp/issues/16. A workaround is to set:
let c_no_curly_error = 1

function! s:SetColorcolumn()
  if &filetype == "go"
    set colorcolumn=100
  elseif &filetype == "man"
    set colorcolumn=
  else
    set colorcolumn=80
  endif
endfunction

augroup CustomFileTypeCommands | autocmd!
  autocmd BufNewFile,BufRead,FileType * call s:SetColorcolumn()
  autocmd BufNewFile,BufRead ghostty.config setfiletype ghostty
  autocmd BufNewFile,BufRead *.aidl,*.hidl setfiletype java
  autocmd BufNewFile,BufRead *.bp set filetype=javascript softtabstop=4 shiftwidth=4
  autocmd FileType go set noexpandtab tabstop=2
  autocmd FileType make set noexpandtab preserveindent
  autocmd FileType man setlocal signcolumn=no | nnoremap <buffer> <silent> q :q<CR>
augroup END

" :help restore-cursor
augroup RestoreCursor
  autocmd!
  autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") | exe "normal g'\"" | endif
augroup END

" Hide cursorline on FocusLost; Show cursorline on FocusGained
augroup SetFocusedCursorline
  autocmd!
  autocmd User Startified setlocal cursorline
  autocmd BufNewFile,BufRead,FocusGained * set cursorline
  autocmd FocusLost * set nocursorline
augroup END

" :help signify.txt
let g:signify_number_highlight = 1
" Always show gutter so it doesn't flicker when making new changes
set signcolumn=yes
" Eagerly update git status
set updatetime=300

function! s:show_current_hunk() abort
  let h = sy#util#get_hunk_stats()
  if !empty(h)
    " Prevents status line flickering :h :echo-redraw
    redraw | echo printf('[Hunk %d/%d]', h.current_hunk, h.total_hunks)
  endif
endfunction

augroup ShowHunkIndexAfterJump
  autocmd!
  autocmd User SignifyHunk call s:show_current_hunk()
augroup END

nnoremap <silent> ]c <plug>(signify-next-hunk):SignifyHunkDiff<CR>
nnoremap <silent> [c <plug>(signify-prev-hunk):SignifyHunkDiff<CR>




" Use CTRL-L to clear the highlighting of 'hlsearch' (off by default) and call :diffupdate.
nnoremap <silent> <C-L> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR><C-L>

" vim-signature
" m[0-9] -> Place markers
" ???, ]=, ]- -> Navigate markers

" Single character *sneak*. `;` => next sneak, `,` => previous sneak.
map f <Plug>Sneak_f
map F <Plug>Sneak_F
map t <Plug>Sneak_t
map T <Plug>Sneak_T

" Shortcuts
nnoremap <F8> :%y +<CR>

" Tab navigations
nnoremap <silent> ]t :tabnext<CR>
nnoremap <silent> [t :tabprevious<CR>
nnoremap <silent> ]T :tablast<CR>
nnoremap <silent> [T :tabfirst<CR>
nnoremap <silent> <A-Right> :<C-U>execute 'tabmove +' . v:count1<CR>
nnoremap <silent> <A-Left> :<C-U>execute 'tabmove -' . v:count1<CR>

" http://vim.wikia.com/wiki/Recover_from_accidental_Ctrl-U
inoremap <C-U> <C-G>u<C-U>
inoremap <C-W> <C-G>u<C-W>

" CTRL-C in visual mode to fast copy to system clipboard.
vnoremap <C-C> "+y

" Change directory to current file directory.
command CD cd %:p:h
command LCD lcd %:p:h

" :help startify.txt
let g:startify_custom_header = ''
let g:startify_skiplist = ['COMMIT_EDITMSG', '.repo/']
augroup StartifiedCursorline | autocmd!
  autocmd User Startified setlocal cursorline
augroup END

" :help vimsuggest.txt
set wildmenu
set wildmode=longest:full,full
set wildoptions=pum,fuzzy
augroup SetVimSuggestOptions | autocmd!
  autocmd VimEnter * call g:VimSuggestSetOptions(#{
        \ cmd: #{reverse: v:true, addon: v:false, popupattrs: #{maxheight: 12}},
        \ search: #{reverse: v:true},
        \ })
augroup END

" Java format style
Glaive codefmt google_java_executable="google-java-format --aosp"

" :help lsp.txt yegappan/lsp
augroup LspConfig | autocmd!
  autocmd User LspSetup call LspOptionsSet(#{
        \ autoHighlightDiags: v:true,
        \ showDiagInBalloon: v:true,
        \ semanticHighlight: v:true,
        \ showInlayHints: v:true,
        "\ hoverInPreview: v:true,
        \ })
  autocmd User LspSetup call LspAddServer(s:lsp_servers)
augroup END
let s:lsp_servers = [#{
      \    name: 'rustlang',
      \    filetype: ['rust'],
      \    path: exepath('rust-analyzer'),
      \    args: [],
      \    syncInit: v:true
      \  }]

" :help vimcomplete.txt
augroup SetVimCompleteOptions | autocmd!
  autocmd VimEnter * call g:VimCompleteOptionsSet(#{
        \ completor: #{infoPopup: v:false},
        \ path: #{enable: v:true, priority: 5, showPathSeparatorAtEnd: v:true},
        \ vimscript: #{enable: v:true, priority: 5},
        \ })
augroup END
" Vimcomplete would map these for us.
" inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
" inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
let g:vimcomplete_tab_enable = v:true
" <CR> shenanigans. Every plugin wants to map <CR>, yet they can't play nice together.
" See: https://github.com/tpope/vim-endwise/issues/22
"   https://github.com/girishji/vimcomplete/blob/main/README.md#enter-key-handling
let g:endwise_no_mappings = v:true
let g:endwise_no_maps = v:true
let g:vimcomplete_cr_enable = v:false
inoremap <expr> <CR>
      \ "\<Plug>(vimcomplete-skip)"
      \ .. (pumvisible() ? "\<C-Y>" : "\<C-G>u\<CR>")
      \ .. "\<Plug>DiscretionaryEnd"

" Colorscheme
set t_Co=256
set termguicolors
set background=dark

let g:everforest_background = 'hard'
let g:everforest_colors_override = {}
let g:everforest_better_performance = 1
function! s:everforest_custom() abort
  let l:palette = everforest#get_palette(g:everforest_background, g:everforest_colors_override)
  call everforest#highlight('Todo', l:palette.fg, l:palette.none, 'bold,italic')
  call everforest#highlight('PmenuMatch', l:palette.red, l:palette.none, 'bold')
endfunction
augroup EverforestCustom | autocmd!
  autocmd ColorScheme everforest call s:everforest_custom()
augroup END
colorscheme everforest

" :help tmux-integration
if !has('gui_running') && &term =~ '^\(screen\|tmux\|xterm\)'
  " Insert / replace / normal = vertical bar / underline / block, :help termcap-cursor-shape
  let &t_SI = "\e[6 q"
  let &t_SR = "\e[4 q"
  let &t_EI = "\e[2 q"

  " Better mouse support, see  :help 'ttymouse'
  set ttymouse=sgr

  " Enable true colors, see  :help xterm-true-color
  set termguicolors
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
  let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"

  " Enable bracketed paste mode, see  :help xterm-bracketed-paste
  let &t_BE = "\<Esc>[?2004h"
  let &t_BD = "\<Esc>[?2004l"
  let &t_PS = "\<Esc>[200~"
  let &t_PE = "\<Esc>[201~"

  " Enable focus event tracking, see  :help xterm-focus-event
  let &t_fe = "\<Esc>[?1004h"
  let &t_fd = "\<Esc>[?1004l"
  execute "set <FocusGained>=\<Esc>[I"
  execute "set <FocusLost>=\<Esc>[O"

  " Enable modified arrow keys, see  :help arrow_modifiers
  execute "silent! set <xUp>=\<Esc>[@;*A"
  execute "silent! set <xDown>=\<Esc>[@;*B"
  execute "silent! set <xRight>=\<Esc>[@;*C"
  execute "silent! set <xLeft>=\<Esc>[@;*D"
endif
