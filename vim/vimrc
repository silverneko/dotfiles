" vim-matchup replaces matchit.vim
" let g:ale_completion_enabled = 1
" let g:ale_hover_cursor = 1
" let g:loaded_matchit = 1
" let g:ale_set_balloons = 1
" let g:ale_floating_preview = 1

" set omnifunc=ale#completion#OmniFunc

let g:vimcomplete_cr_enable = 0

" :PlugInstall
call plug#begin('~/.vim/plugged')

"Plug 'sainnhe/gruvbox-material'
Plug 'sainnhe/everforest'
Plug 'itchyny/lightline.vim'
Plug 'mhinz/vim-startify'
Plug 'mhinz/vim-signify'

Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'

Plug 'kshenoy/vim-signature'
Plug 'andymass/vim-matchup'
Plug 'justinmk/vim-sneak'

Plug 'tpope/vim-endwise'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-sleuth'
Plug 'tpope/vim-surround'

Plug 'girishji/vimsuggest'

Plug 'girishji/vimcomplete'
Plug 'yegappan/lsp'

"Plug 'dense-analysis/ale'

Plug 'bfrg/vim-c-cpp-modern'
"Plug 'fidian/hexmode'

Plug 'google/vim-maktaba'
Plug 'google/vim-glaive'
Plug 'google/vim-codefmt'

call plug#end()

call glaive#Install()

let g:google_vimrc=expand('~/.dotfiles/vimrc.google')
if filereadable(g:google_vimrc)
  exec 'source' g:google_vimrc
endif

Glaive codefmt google_java_executable="google-java-format --aosp"

syntax enable
filetype plugin indent on

set nocompatible

" :help persistent-undo
let undo_dir='/tmp/vim_undo'
if !isdirectory(undo_dir)
  call mkdir(undo_dir, 'p')
endif
let &undodir=undo_dir
set undofile

" set completeopt=menuone,noselect
" set shortmess+=c

" inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
" inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"

" let vcoptions = {}
" autocmd VimEnter * call g:VimCompleteOptionsSet(vcoptions)

" inoremap <CR> <C-r>=<SID>my_cr_function()<CR>
" function! s:my_cr_function()
"   return pumvisible() ? "\<C-y>" : "\<CR>"
" endfunction
" inoremap <expr> <cr>    pumvisible() ? "\<c-y>" : "\<cr>"
" inoremap <expr> <cr>    pumvisible() ? asyncomplete#close_popup() : "\<cr>"

" let lspOpts = #{autoHighlightDiags: v:true,
"       \ noNewlineInCompletionEver: v:true,
"       \ showInlayHints: v:true}
" autocmd User LspSetup call LspOptionsSet(lspOpts)

" let lspServers = [#{
" 	\    name: 'rustlang',
" 	\    filetype: ['rust'],
"         \    path: exepath('rust-analyzer'),
" 	\    args: [],
" 	\    syncInit: v:true
" 	\  }]
" autocmd User LspSetup call LspAddServer(lspServers)

" gruvbox
set t_Co=256
set termguicolors
set background=dark
" let g:gruvbox_material_background = 'hard'
" let g:gruvbox_material_better_performance = 1
" let g:gruvbox_material_visual = 'blue background'
" colorscheme gruvbox-material
let g:everforest_background = 'hard'
let g:everforest_colors_override = {}
let g:everforest_better_performance = 1

function! s:everforest_custom() abort
  let l:palette = everforest#get_palette(g:everforest_background, g:everforest_colors_override)
  call everforest#highlight('Todo', l:palette.fg, l:palette.none, 'bold,italic')
endfunction

augroup EverforestCustom
  autocmd!
  autocmd ColorScheme everforest call s:everforest_custom()
augroup END

colorscheme everforest

" lightline
set noshowmode
set display+=lastline
set cmdheight=1
set laststatus=2

let g:lightline = {
      \ 'colorscheme': 'everforest',
      \ 'active': {
      \   'left': [
      \     ['mode', 'paste'],
      \     ['relativepath', 'readonly'],
      \     ['modified'],
      \   ],
      \   'right': [
      \     ['percentwin'],
      \     ['line', 'column'],
      \     ['gitbranch', 'filetype', 'my_fileencoding', 'charhexvalue'] ,
      \   ],
      \ },
      \ 'tabline': {'left': [['tabs']], 'right': []},
      \ 'tab': {'active': ['tabtitle'], 'inactive': ['tabtitle']},
      \ 'component': {
      \   'charhexvalue': '0x%02B',
      \   'modified': '%m',
      \   'line': '%3l/%LL',
      \   'column': '%2vC',
      \ },
      \ 'component_function': {
      \   'gitbranch': 'gitbranch#name',
      \   'my_fileencoding': 'MyFileencoding',
      \ },
      \ 'component_expand': {'tabs': 'MyLightlineTabs'},
      \ 'tab_component_function': {'tabtitle': 'MyTabTitle'},
      \ 'tabline_subseparator': {'left': '', 'right': ''},
      \ }

function! MyFileencoding()
  let l:enc = &fenc !=# "" ? &fenc : &enc
  return l:enc ==? "utf-8" ? "" : l:enc
endfunction

function! MyTabTitle(n)
  return '[' . a:n . '] ' . lightline#tab#filename(a:n) . (lightline#tab#modified(a:n) == '+' ? '*' : '')
endfunction

function! MyLightlineTabs() abort
  let [x, y, z] = [[], [], []]
  let nr = tabpagenr()
  let cnt = tabpagenr('$')
  for i in range(1, cnt)
    call add(i < nr ? x : i == nr ? y : z, (i > nr + 3 ? '%<' : '') . '%' . i . 'T%{lightline#onetab(' . i . ',' . (i == nr) . ')}' . (i == cnt ? '%T' : ''))
  endfor
  return [x, y, z]
endfunction

set ttimeout
augroup NoInsertKeycodes
  autocmd!
  autocmd InsertEnter * set ttimeoutlen=0
  autocmd InsertLeave * set ttimeoutlen=100 "<--- default value; also try 100 or something
augroup END

" j: Delete comment character when joining commented lines.
" o: Insert comment leader when 'o' / 'O' in Normal mode.
augroup SetFormatOptions
  autocmd!
  autocmd BufNewFile,BufRead * setlocal formatoptions-=o formatoptions+=j
augroup END

" Show search count like "[1/5]"
set shortmess-=S

set nomodeline
set noerrorbells
set splitbelow
set scrolloff=5
set sidescroll=1
set sidescrolloff=5
set history=1000
set sessionoptions-=options
set viewoptions-=options
" Persist g:UPPERCASE variables, used by some plugins, in .viminfo.
set viminfo^=!
" vim -p <FILES...> / vim <FILES...> && :tab all
set tabpagemax=50
" Disable a legacy behavior that can break plugin maps. (???)
set nolangremap

set cursorline
set ruler
set number
set numberwidth=5
set mouse=nv
set guifont=DejaVu\ Sans\ Mono\ 14
set guicursor+=a:blinkon0

set listchars=trail:␣,tab:»\ ,nbsp:¬
set list

set backspace=indent,eol,start
set history=500      " keep 500 lines of command line history
set showcmd          " display incomplete commands
set incsearch        " do incremental searching
set hlsearch
set ignorecase smartcase

" Tab things
set tabstop=8        "A tab is 8 spaces
set expandtab        "Always uses spaces instead of tabs
set softtabstop=2    "Insert 2 spaces when tab is pressed
set shiftwidth=2     "An indent is 2 spaces
set shiftround       "Round indent to nearest shiftwidth multiple

set autoindent
" Set a few indentation parameters. See the VIM help for cinoptions-values for
" details.  These aren't absolute rules; they're just an approximation of
" common style in LLVM source.
set cinoptions=:0,g0,(0,Ws,l1
" Vim tend to a have issues with flagging braces as errors, see for example
" https://github.com/vim-jp/vim-cpp/issues/16. A workaround is to set:
let c_no_curly_error = 1

function! s:SetColorcolumn()
  if &filetype == "go"
    set colorcolumn=100
  elseif &filetype == "man"
    set colorcolumn=
  else
    set colorcolumn=80
  endif
endfunction

augroup CustomFileTypeCommands | autocmd!
  autocmd BufNewFile,BufRead,FileType * call s:SetColorcolumn()
  autocmd BufNewFile,BufRead ghostty.config setfiletype ghostty
  autocmd BufNewFile,BufRead *.aidl,*.hidl setfiletype java
  autocmd BufNewFile,BufRead *.bp set filetype=javascript softtabstop=4 shiftwidth=4
  autocmd FileType go set noexpandtab tabstop=2
  autocmd FileType make set noexpandtab preserveindent
  autocmd FileType man setlocal signcolumn=no | nnoremap <buffer> <silent> q :q<CR>
augroup END

" :help restore-cursor
augroup RestoreCursor
  autocmd!
  autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") | exe "normal g'\"" | endif
augroup END

" Hide cursorline on FocusLost; Show cursorline on FocusGained
augroup SetFocusedCursorline
  autocmd!
  autocmd User Startified setlocal cursorline
  autocmd BufNewFile,BufRead,FocusGained * set cursorline
  autocmd FocusLost * set nocursorline
augroup END

" :help signify.txt
let g:signify_number_highlight = 1
" Always show gutter so it doesn't flicker when making new changes
set signcolumn=yes
" Eagerly update git status
set updatetime=300

function! s:show_current_hunk() abort
  let h = sy#util#get_hunk_stats()
  if !empty(h)
    " Prevents status line flickering :h :echo-redraw
    redraw | echo printf('[Hunk %d/%d]', h.current_hunk, h.total_hunks)
  endif
endfunction

augroup ShowHunkIndexAfterJump
  autocmd!
  autocmd User SignifyHunk call s:show_current_hunk()
augroup END

nnoremap <silent> ]c <plug>(signify-next-hunk):SignifyHunkDiff<CR>
nnoremap <silent> [c <plug>(signify-prev-hunk):SignifyHunkDiff<CR>

" :help tmux-integration
if !has('gui_running') && &term =~ '^\(screen\|tmux\|xterm\)'
  " Insert / replace / normal = vertical bar / underline / block, :help termcap-cursor-shape
  let &t_SI = "\e[6 q"
  let &t_SR = "\e[4 q"
  let &t_EI = "\e[2 q"

  " Better mouse support, see  :help 'ttymouse'
  set ttymouse=sgr

  " Enable true colors, see  :help xterm-true-color
  set termguicolors
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
  let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"

  " Enable bracketed paste mode, see  :help xterm-bracketed-paste
  let &t_BE = "\<Esc>[?2004h"
  let &t_BD = "\<Esc>[?2004l"
  let &t_PS = "\<Esc>[200~"
  let &t_PE = "\<Esc>[201~"

  " Enable focus event tracking, see  :help xterm-focus-event
  let &t_fe = "\<Esc>[?1004h"
  let &t_fd = "\<Esc>[?1004l"
  execute "set <FocusGained>=\<Esc>[I"
  execute "set <FocusLost>=\<Esc>[O"

  " Enable modified arrow keys, see  :help arrow_modifiers
  execute "silent! set <xUp>=\<Esc>[@;*A"
  execute "silent! set <xDown>=\<Esc>[@;*B"
  execute "silent! set <xRight>=\<Esc>[@;*C"
  execute "silent! set <xLeft>=\<Esc>[@;*D"
endif

" Use CTRL-L to clear the highlighting of 'hlsearch' (off by default) and call :diffupdate.
nnoremap <silent> <C-L> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR><C-L>

" vim-signature
" m[0-9] -> Place markers
" ???, ]=, ]- -> Navigate markers

" Single character *sneak*. `;` => next sneak, `,` => previous sneak.
map f <Plug>Sneak_f
map F <Plug>Sneak_F
map t <Plug>Sneak_t
map T <Plug>Sneak_T

" Shortcuts
nnoremap <F8> :%y +<CR>

" Tab navigations
nnoremap <silent> ]t :tabnext<CR>
nnoremap <silent> [t :tabprevious<CR>
nnoremap <silent> ]T :tablast<CR>
nnoremap <silent> [T :tabfirst<CR>
nnoremap <silent> <A-Right> :<C-U>execute 'tabmove +' . v:count1<CR>
nnoremap <silent> <A-Left> :<C-U>execute 'tabmove -' . v:count1<CR>

" http://vim.wikia.com/wiki/Recover_from_accidental_Ctrl-U
inoremap <C-U> <C-G>u<C-U>
inoremap <C-W> <C-G>u<C-W>

" CTRL-C in visual mode to fast copy to system clipboard.
vnoremap <C-C> "+y

" Change directory to current file directory.
command CD cd %:p:h
command LCD lcd %:p:h

" :help startify.txt
let g:startify_custom_header = ''
let g:startify_skiplist = ['COMMIT_EDITMSG', '.repo/']

" :help vimsuggest.txt
set wildmenu
set wildmode=longest:full,full
set wildoptions=pum,fuzzy
let s:vim_suggest = {
      \ 'cmd': {'reverse': v:true, 'popupattrs': {'maxheight': 12}, 'addons': v:false},
      \ 'search': {'reverse': v:true},
      \ }
augroup SetVimSuggestOptions
  autocmd!
  autocmd VimEnter * call g:VimSuggestSetOptions(s:vim_suggest)
augroup END
